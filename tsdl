#!/bin/bash
# tsdl - Download TS segments from an HLS playlist and combine them into a video,
#       while tracking and displaying the total downloaded size in-place.

# Usage: tsdl <URL> [output_file_path]
if [[ -z "$1" ]]; then
    echo "Usage: $0 <URL> [output_file_path]"
    exit 1
fi

URL="$1"

# Determine output file path; if not provided, default to ./downloads/output.mp4
if [[ -n "$2" ]]; then
    OUTPUT_PATH="$2"
else
    OUTPUT_DIR="./downloads"
    mkdir -p "$OUTPUT_DIR"
    OUTPUT_PATH="$OUTPUT_DIR/output.mp4"
fi

# Check that OUTPUT_PATH ends with a valid video file extension.
if [[ ! "$OUTPUT_PATH" =~ \.(mp4|MP4|mkv|MKV|avi|AVI|mov|MOV|flv|FLV)$ ]]; then
    echo "Error: The output file must have a valid video extension (e.g., .mp4, .mkv, .avi, .mov, .flv)."
    exit 1
fi

# Extract names
OUTPUT_DIR=$(dirname "$OUTPUT_PATH")
OUTPUT_FILENAME=$(basename "$OUTPUT_PATH")
OUTPUT_NAME="${OUTPUT_FILENAME%.*}"

# Create temporary directory for cache files: add .temp suffix to output path
TMP_DIR="${OUTPUT_PATH}.temp"
mkdir -p "$TMP_DIR"
STATE_FILE="$TMP_DIR/${OUTPUT_NAME}_state.txt"
MAX_RETRIES=10

# Initialize total size counter (in bytes)
TOTAL_BYTES=0

# Resume progress if state file exists
COMPLETED_FILES=0
if [[ -f "$STATE_FILE" ]]; then
    COMPLETED_FILES=$(cat "$STATE_FILE")
    echo "Resuming from file #$COMPLETED_FILES..."
    # Sum sizes of already-downloaded segments
    for ((i=1; i<=COMPLETED_FILES; i++)); do
        PART_FILE="$TMP_DIR/${OUTPUT_NAME}_part_${i}.ts"
        if [[ -f "$PART_FILE" ]]; then
            SIZE=$(stat -c%s "$PART_FILE" 2>/dev/null || stat -f%z "$PART_FILE")
            TOTAL_BYTES=$((TOTAL_BYTES + SIZE))
        fi
    done
    TOTAL_MB=$((TOTAL_BYTES / 1024 / 1024))
    echo "Already downloaded: ${TOTAL_MB}MB across $COMPLETED_FILES files."
else
    echo "Starting fresh download..."
    echo "0" > "$STATE_FILE"
fi

# Fetch playlist and allow resolution selection if this is a master playlist
echo "Fetching playlist..."
MASTER_CONTENT=$(curl -s "$URL" | tr -d '\r')
if echo "$MASTER_CONTENT" | grep -q "#EXT-X-STREAM-INF"; then
    echo "Detected master playlist. Available resolutions:"
    declare -a res_array url_array
    idx=0
    while IFS= read -r line; do
        line=$(echo "$line" | tr -d '\r')
        if [[ $line == \#EXT-X-STREAM-INF* ]]; then
            res_array[idx]=$(echo "$line" | sed -nE 's/.*RESOLUTION=([^,]*).*/\1/p')
            read -r next_line
            next_line=$(echo "$next_line" | tr -d '\r')
            url_array[idx]="$next_line"
            idx=$((idx+1))
        fi
    done <<< "$MASTER_CONTENT"
    for i in "${!res_array[@]}"; do
        echo "$((i+1)): ${res_array[i]}"
    done
    echo -n "Enter your choice: "
    read choice
    if ! [[ "$choice" =~ ^[0-9]+$ ]] || (( choice<1 || choice>${#res_array[@]} )); then
        echo "Invalid choice. Exiting."
        exit 1
    fi
    sel=$((choice-1))
    PLAYLIST_URL="${url_array[sel]}"
    # Resolve relative URLs
    if [[ "$PLAYLIST_URL" != http* ]]; then
        if [[ "$PLAYLIST_URL" == /* ]]; then
            BASE=$(echo "$URL" | sed -E 's|(https?://[^/]+).*|\1|')
            PLAYLIST_URL="$BASE$PLAYLIST_URL"
        else
            PLAYLIST_URL="$(dirname "$URL")/$PLAYLIST_URL"
        fi
    fi
    echo "Selected resolution: ${res_array[sel]} -> $PLAYLIST_URL"
else
    PLAYLIST_URL="$URL"
fi

echo "Fetching TS file URLs from playlist..."
TS_URLS=$(curl -s "$PLAYLIST_URL" | tr -d '\r' | grep -v '^#')
TOTAL_FILES=$(echo "$TS_URLS" | wc -l)
echo "Found $TOTAL_FILES TS files in the playlist."

echo "Starting download of $TOTAL_FILES files..."
declare -a TS_FILES
CURRENT_FILE=0
for TS_URL in $TS_URLS; do
    # Build absolute URL if needed
    if [[ "$TS_URL" != http* ]]; then
        if [[ "$TS_URL" == /* ]]; then
            BASE=$(echo "$PLAYLIST_URL" | sed -E 's|(https?://[^/]+).*|\1|')
            TS_URL="$BASE$TS_URL"
        else
            TS_URL="$(dirname "$PLAYLIST_URL")/$TS_URL"
        fi
    fi
    CURRENT_FILE=$((CURRENT_FILE+1))
    if (( CURRENT_FILE <= COMPLETED_FILES )); then
        printf "\rProgress: %3d%% | Files: %d/%d | Total: %dMB" \
          $((COMPLETED_FILES*100/TOTAL_FILES)) $CURRENT_FILE $TOTAL_FILES $((TOTAL_BYTES/1024/1024))
        TS_FILES+=("$TMP_DIR/${OUTPUT_NAME}_part_${CURRENT_FILE}.ts")
        continue
    fi
    TEMP_FILE="$TMP_DIR/${OUTPUT_NAME}_part_${CURRENT_FILE}.ts"

    # Download segment
    ATTEMPT=0; SUCCESS=0
    while (( ATTEMPT < MAX_RETRIES )); do
        ((ATTEMPT++))
        curl -s "$TS_URL" --output "$TEMP_FILE"
        [[ $? -eq 0 && -s "$TEMP_FILE" ]] && { SUCCESS=1; break; }
    done
    if (( SUCCESS != 1 )); then
        echo "\nFailed to download segment $CURRENT_FILE after $MAX_RETRIES attempts. Skipping."
        continue
    fi

    # Track downloaded bytes and update state
    FILE_BYTES=$(stat -c%s "$TEMP_FILE" 2>/dev/null || stat -f%z "$TEMP_FILE")
    TOTAL_BYTES=$((TOTAL_BYTES + FILE_BYTES))
    printf "\rProgress: %3d%% | Files: %d/%d | Last: %4dMB | Total: %dMB" \
        $((CURRENT_FILE*100/TOTAL_FILES)) $CURRENT_FILE $TOTAL_FILES $((FILE_BYTES/1024/1024)) $((TOTAL_BYTES/1024/1024))

    # Save state
    echo "$CURRENT_FILE" > "$STATE_FILE"

    TS_FILES+=("$TEMP_FILE")
done

# Ensure the final progress line ends with a newline
echo ""

# ── NEW CONCAT & MERGE SECTION ──
echo "Generating concat list (just basenames) and merging..."

pushd "$TMP_DIR" > /dev/null

# Create a simple concat_list.txt with only TS filenames
> concat_list.txt
for seg in ${OUTPUT_NAME}_part_*.ts; do
    echo "file '$seg'" >> concat_list.txt
done

# Run ffmpeg from inside the temp dir; output goes one level up
ffmpeg -y -f concat -safe 0 \
    -i concat_list.txt \
    -c copy "../${OUTPUT_FILENAME}"

popd > /dev/null
# ────────────────────────────────

echo "Conversion finished: $OUTPUT_PATH"

# Cleanup prompt
echo -n "Delete temporary directory ($TMP_DIR)? (y/N): "
read resp
if [[ "$resp" =~ ^[Yy]$ ]]; then
    rm -rf "$TMP_DIR"
    echo "Temporary directory removed."
else
    echo "Temporary directory retained at: $TMP_DIR"
fi

echo "Process finished."
