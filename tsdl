#!/bin/bash
# tsdl - Download TS segments from an HLS playlist and combine them into a video,
#       while tracking and displaying the total downloaded size in-place,
#       and skipping any corrupt or unreadable segments.

# Usage: tsdl <URL> [output_file_path]
if [[ -z "$1" ]]; then
    echo "Usage: $0 <URL> [output_file_path]"
    exit 1
fi

URL="$1"

# Determine output file path; if not provided, default to ./downloads/output.mp4
if [[ -n "$2" ]]; then
    OUTPUT_PATH="$2"
else
    OUTPUT_DIR="./downloads"
    mkdir -p "$OUTPUT_DIR"
    OUTPUT_PATH="$OUTPUT_DIR/output.mp4"
fi

# Validate extension
if [[ ! "$OUTPUT_PATH" =~ \.(mp4|MP4|mkv|MKV|avi|AVI|mov|MOV|flv|FLV)$ ]]; then
    echo "Error: The output file must have a valid video extension."
    exit 1
fi

# Names & temp dir
OUTPUT_DIR=$(dirname "$OUTPUT_PATH")
OUTPUT_FILENAME=$(basename "$OUTPUT_PATH")
OUTPUT_NAME="${OUTPUT_FILENAME%.*}"
TMP_DIR="${OUTPUT_PATH}.temp"
mkdir -p "$TMP_DIR"
STATE_FILE="$TMP_DIR/${OUTPUT_NAME}_state.txt"
PLAYLIST_CACHE="$TMP_DIR/playlist_url.txt"
MAX_RETRIES=10

# 1) Resume state
TOTAL_BYTES=0
COMPLETED_FILES=0
if [[ -f "$STATE_FILE" ]]; then
    COMPLETED_FILES=$(<"$STATE_FILE")
    echo "Resuming from file #$COMPLETED_FILES..."
    for ((i=1; i<=COMPLETED_FILES; i++)); do
        f="$TMP_DIR/${OUTPUT_NAME}_part_${i}.ts"
        [[ -f "$f" ]] && TOTAL_BYTES=$((TOTAL_BYTES + $(stat -c%s "$f" 2>/dev/null || stat -f%z "$f")))
        TOTAL_MB=$((TOTAL_BYTES / 1024 / 1024))
        printf "\rCalculating total segment size: %4dMB in %4d files\r" $TOTAL_MB $COMPLETED_FILES
    done
    echo "Already downloaded: $((TOTAL_BYTES/1024/1024))MB in $COMPLETED_FILES files."
else
    echo "Starting fresh download..."
    echo "0" > "$STATE_FILE"
fi

# 2) Determine playlist URL (cache on first run)
if [[ -f "$PLAYLIST_CACHE" ]]; then
    PLAYLIST_URL=$(<"$PLAYLIST_CACHE")
    echo "Using cached playlist: $PLAYLIST_URL"
else
    echo "Fetching playlist..."
    MASTER_CONTENT=$(curl -s "$URL" | tr -d '\r')
    if grep -q "#EXT-X-STREAM-INF" <<<"$MASTER_CONTENT"; then
        echo "Detected master playlist. Available resolutions:"
        declare -a res_array url_array; idx=0
        while IFS= read -r line; do
            line=${line//$'\r'/}
            if [[ $line == \#EXT-X-STREAM-INF* ]]; then
                res_array[idx]=$(sed -nE 's/.*RESOLUTION=([^,]*).*/\1/p' <<<"$line")
                read -r next_line
                url_array[idx]=${next_line//$'\r'/}
                idx=$((idx+1))
            fi
        done <<<"$MASTER_CONTENT"
        for i in "${!res_array[@]}"; do
            echo "  $((i+1)): ${res_array[i]}"
        done
        read -p "Enter your choice: " choice
        if ! [[ "$choice" =~ ^[0-9]+$ ]] || (( choice<1 || choice>${#res_array[@]} )); then
            echo "Invalid choice."; exit 1
        fi
        sel=$((choice-1))
        PLAYLIST_URL="${url_array[sel]}"
        if [[ "$PLAYLIST_URL" != http* ]]; then
            if [[ "$PLAYLIST_URL" == /* ]]; then
                BASE=$(sed -E 's|(https?://[^/]+).*|\1|' <<<"$URL")
                PLAYLIST_URL="$BASE$PLAYLIST_URL"
            else
                PLAYLIST_URL="$(dirname "$URL")/$PLAYLIST_URL"
            fi
        fi
    else
        PLAYLIST_URL="$URL"
    fi
    echo "$PLAYLIST_URL" > "$PLAYLIST_CACHE"
    echo "Playlist set to: $PLAYLIST_URL"
fi

# 3) Fetch TS URLs
TS_URLS=$(curl -s "$PLAYLIST_URL" | tr -d '\r' | grep -v '^#')
TOTAL_FILES=$(wc -l <<<"$TS_URLS")
echo "Found $TOTAL_FILES TS files."

# 4) Download loop
declare -a TS_FILES
CURRENT_FILE=0
for TS in $TS_URLS; do
    if [[ "$TS" != http* ]]; then
        if [[ "$TS" == /* ]]; then
            BASE=$(sed -E 's|(https?://[^/]+).*|\1|' <<<"$PLAYLIST_URL")
            TS="$BASE$TS"
        else
            TS="$(dirname "$PLAYLIST_URL")/$TS"
        fi
    fi
    CURRENT_FILE=$((CURRENT_FILE+1))
    OUT="$TMP_DIR/${OUTPUT_NAME}_part_${CURRENT_FILE}.ts"
    if (( CURRENT_FILE <= COMPLETED_FILES )); then
        printf "\rSkipping %4d/%4d (already have it)" $CURRENT_FILE $TOTAL_FILES
        TS_FILES+=("$OUT")
        continue
    fi
    for ((a=1; a<=MAX_RETRIES; a++)); do
        curl -s "$TS" -o "$OUT" && [[ -s "$OUT" ]] && break
        [[ $a -eq $MAX_RETRIES ]] && echo -e "\nFailed segment $CURRENT_FILE" && break
    done
    SZ=$(stat -c%s "$OUT" 2>/dev/null || stat -f%z "$OUT")
    TOTAL_BYTES=$((TOTAL_BYTES+SZ))
    printf "\rProgress: %3d%% | %4d/%4d | Last: %4dKB | Total: %4dMB" \
      $((CURRENT_FILE*100/TOTAL_FILES)) $CURRENT_FILE $TOTAL_FILES $((SZ/1024)) $((TOTAL_BYTES/1024/1024))
    echo "$CURRENT_FILE" > "$STATE_FILE"
    TS_FILES+=("$OUT")
done
echo

# 5) Concat & merge with skipping of bad segments
echo "Combining segments..."
pushd "$TMP_DIR" >/dev/null

> concat_list.txt
for seg in $(ls -1v ${OUTPUT_NAME}_part_*.ts); do
    # Skip empty files outright
    if [[ ! -s "$seg" ]]; then
        echo "Warning: skipping empty segment $seg"
        continue
    fi

    # Probe with ffprobe; only keep if it exits cleanly
    if ffprobe -v error -i "$seg" -f null - 2>/dev/null; then
        echo "file '$seg'" >> concat_list.txt
    else
        echo "Warning: skipping unreadable segment $seg"
    fi
done

ffmpeg -y -f concat -safe 0 \
    -i concat_list.txt \
    -c copy "../${OUTPUT_FILENAME}"

popd >/dev/null
echo "Conversion finished: $OUTPUT_PATH"

# 6) Cleanup
read -p "Delete temp dir ($TMP_DIR)? (y/N): " resp
if [[ "$resp" =~ ^[Yy]$ ]]; then
    rm -rf "$TMP_DIR"
    echo "Cleaned up."
else
    echo "Temp retained at $TMP_DIR"
fi

echo "Done."
